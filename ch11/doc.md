# 11. 测试
## 11.1 go test
* go test是按照一定的约定和组织来测试代码的程序.在包目录内,所有以_test.go为后缀名的源文件在执行 go build 的时候,都不会被构建成包的一部分.他们是 go test 测试的一部分
* *_test.go文件中,有3种类型的函数:
    1. 测试函数 是以 Test为函数名前缀的函数,用于测试程序的一些逻辑是否正确. go test 报告测试结果 : PASS/FAIL 
    2. 基准测试函数 是以Benchmark为函数名前缀的函数. 用于衡量一些函数的性能, go test 会多次运行基准测试函数以计算一个平均执行时间
    3. 示例函数. 是以 Example为函数名前缀的函数,提供一个由编译器保证正确性的示例文档.
* go test命令会变量所有*_test.go文件中符号上述命名规则的函数,生成一个临时的 main包用于调用相应的测试函数,接着构建 运行 报告测试结果,最后清理测试中生成的临时文件
## 11.2 测试函数
* 每个测试函数必须导入 testing包.测试函数有如下签名:
```
func TestName(t *testing.T) {
    // ...
}
```
* 测试函数的名字必须以 Test开头,可选的后缀必须以大写字母开头
```
func TestSin(t *testing.T) {}
func TestCos(t *testing.T) {}
```
* t 参数用于报告测试失败和附加的日志信息.
* go test 命令如果没有参数指定包那么将默认采用当前目录对应的包(和 go build 一样)
* go test -v  -v可用于打印每个测试函数的名字和运行时间
* go test -run="French|Canal"  -run对应一个正则表达式,只有测试函数名被它正确匹配的测试函数才会被go test测试命名运行
* 当然，一旦我们已经修复了失败的测试用例，在我们提交代码更新之前，我们应该以不带参数的go test命令运行全部的测试用例，以确保修复失败测试的同时没有引入新的问题。
* 用的是 byte而不是 rune序列,所以像“été”中的é等非 ACII字符不能被正确处理
* 以表格为驱动的测试在 go 中特别常见,我们可以更加容易的向表格中添加新的测试数据
* t.Errorf 的调用并不会引起panic异常或停止测试执行,即使前面的数据测试失败了,表格后面的测试数据依然会运行测试,
* 如果真的需要停止测试,t.Fatal或 t.Fatalf 可以停止当前测试函数
* 测试失败的信息一般是 f(x)=y,want z,其中 f(x)代表操作和输入,y是实际运行结果,z 是期望的正确结果
* 在测试中类似 IsPalindrome返回 bool 类型的函数时候,我们可以忽略没有啥信息的 z部分
### 11.2.1 随机测试
* 表格驱动的测试便于构造基于精挑细选的测试数据的测试示例.另一种测试思路是随机测试,也就是通过构造更加广泛的随机输入来测试探索函数的行为
* 两种策略:
    1. 编写对照函数,使用简单和清晰的算法,虽然效率较低但是行为要和测试的函数是一致的,然后针对相同的随机输入检测两者的输出结果,
    2. 生成随机输入的数据遵循特定的模式,这样我们就知道期望的输出模式
* 通过使用当前时间作为随机种子，在整个过程中的每次运行测试命令时都将探索新的随机数据。如果你使用的是定期运行的自动化测试集成系统，随机测试将特别有价值。

### 11.2.2 测试一个命令
* 对于测试包go test是一个有用的工具，但是稍加努力我们也可以用它来测试可执行程序。
如果一个包的名字是 main，那么在构建时会生成一个可执行程序，不过main包可以作为一个包被测试器代码导入
* 错误信息描述了尝试的操作（使用Go类似语法），实际的结果和期望的结果。通过这样的错误信息，你可以在检视代码之前就很容易定位错误的原因。
* 要注意的是在测试代码中并没有调用log.Fatal或os.Exit，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。
如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理。如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理。
幸运的是（上面的意外只是一个插曲），我们的echo示例是比较简单的也没有需要返回非空error的情况。

### 11.2.3 白盒测试
* 一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。黑盒测试只需要测试包公开的文档和API行为，内部实现对测试代码是透明的。
相反，白盒测试有访问包内部函数和数据结构的权限，因此可以做到一些普通客户端无法实现的测试。
例如，一个白盒测试可以在每个操作之后检测不变量的数据类型。（白盒测试只是一个传统的名称，其实称为clear box测试会更准确。）
* 我们已经看到两种测试的例子。TestIsPalindrome测试仅仅使用导出的IsPalindrome函数，因此这是一个黑盒测试。
TestEcho测试则调用了内部的echo函数，并且更新了内部的out包级变量，这两个都是未导出的，因此这是白盒测试。
* 当用户使用了超过90%的存储配额之后将发送提醒邮件。（译注：一般在实现业务机器监控，包括磁盘、cpu、网络等的时候，需要类似的到达阈值=>触发报警的逻辑，所以是很实用的案例。）
* 这种处理模式可以用来暂时保存和恢复所有的全局变量，包括命令行标志参数、调试选项和优化参数；安装和移除导致生产代码产生一些调试信息的钩子函数；还有有些诱导生产代码进入某些重要状态的改变，比如超时、错误，甚至是一些刻意制造的并发行为等因素。

### 11.2.4 外部测试包
* Go语言规范是禁止包的循环依赖的。
* 不过我们可以通过外部测试包的方式解决循环依赖的问题，也就是在net/url包所在的目录声明一个独立的url_test测试包。其中包名的_test后缀告诉go test工具它应该建立一个额外的包来运行测试。我们将这个外部测试包的导入路径视作是net/url_test会更容易理解，但实际上它并不能被其他任何包导入。
* 因为外部测试包是一个独立的包，所以能够导入那些依赖待测代码本身的其他辅助包；包内的测试代码就无法做到这点。在设计层面，外部测试包是在所有它依赖的包的上层，正如图11.2所示。
* 通过避免循环的导入依赖，外部测试包可以更灵活地编写测试，特别是集成测试（需要测试多个组件之间的交互），可以像普通应用程序那样自由地导入其他包。
* 我们可以用go list命令查看包对应目录中哪些Go源文件是产品代码，哪些是包内测试，还有哪些是外部测试包。我们以fmt包作为一个例子：GoFiles表示产品代码对应的Go源文件列表；也就是go build命令要编译的部分。
```
// GoFiles表示产品代码对应的Go源文件列表；也就是go build命令要编译的部分。
go list -f={{.GoFiles}} fmt
// TestGoFiles表示的是fmt包内部测试代码，以_test.go为后缀文件名，不过只在测试时被构建：
go list -f={{.TestGoFiles}} fmt
// XTestGoFiles表示的是属于外部测试包的测试代码，也就是fmt_test包，因此它们必须先导入fmt包。同样，这些文件也只是在测试时被构建运行：
go list -f={{.XTestGoFiles}} fmt
```
* 有时候外部测试包也需要访问被测试包内部的代码，例如在一个为了避免循环导入而被独立到外部测试包的白盒测试。在这种情况下，
我们可以通过一些技巧解决：我们在包内的一个_test.go文件中导出一个内部的实现给外部测试包。因为这些代码只有在测试时才需要，因此一般会放在export_test.go文件中。

### 11.2.5 编写有效的测试
* 从这个意义上说，断言函数犯了过早抽象的错误：仅仅测试两个整数是否相同，而没能根据上下文提供更有意义的错误信息。我们可以根据具体的错误打印一个更有价值的错误信息，就像下面例子那样。只有在测试中出现重复模式时才采用抽象。

##11.3 测试覆盖率
* 对待测程序执行的测试的程度称为测试的覆盖率. 
* 语句的测试覆盖率是最简单和最广泛的.语句的测试覆盖率指在测试中至少被运行一次的代码占总代码数的比例
* 
```
pwd : /Users/v_duanjiawei/go/src/gopl.io
go test -run="Coverage" ch7/eval
can't load package: package ch7/eval: cannot find package "ch7/eval" in any of:
        /usr/local/go/src/ch7/eval (from $GOROOT)
        /Users/v_duanjiawei/go/src/ch7/eval (from $GOPATH)

go test -run="Coverage" gopl.io/ch7/eval  ok
```
* go tool命令运行Go工具链的底层可执行程序。这些底层可执行程序放在$GOROOT/pkg/tool/${GOOS}_${GOARCH}目录。因为有go build命令的原因，我们很少直接调用这些底层工具
* go test -run=Coverage -coverprofile=c.out  生成统计文件和显示摘要
* go test -run=Coverage -cover 只显示摘要
* 这个标志参数通过在测试代码中插入生成钩子来统计覆盖率数据。也就是说，在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。
当被修改后的被测试代码运行退出时，将统计日志数据写入c.out文件，并打印一部分执行的语句的一个总结。（如果你需要的是摘要，使用go test -cover。）
* go test -covermode=count 如果使用了-covermode=count标志参数，那么将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，这可以用于衡量哪些是被频繁执行的热点代码。
* go tool cover -html=c.out 生成 html报告
* 绿色的代码块被测试覆盖到了，红色的则表示没有被覆盖到

##11.4 基准测试
* 基准测试是测试一个程序在固定工作负载下的性能.
* Go Benchmark为前缀名,并带有一个*testing.B 类型的参数:*testing.B 参数除了提供和*testing.T 类似的方法之外,还有额外的一些和性能测试相关的方法.
它提供了一个整数 N,用于指定操作循环的次数
* 默认情况下不运行任何基准测试。我们需要通过-bench命令行标志参数手工指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。
其中“.”模式将可以匹配所有基准测试函数，但因为这里只有一个基准测试函数，因此和-bench=IsPalindrome参数是等价的效果。
* 结果中基准测试名的数字后缀部分，这里是8，表示运行时对应的GOMAXPROCS的值，这对于一些与并发相关的基准测试是重要的信息。
* 报告显示每次调用IsPalindrome函数花费1.035微秒，是执行1,000,000次的平均时间。因为基准测试驱动器开始时并不知道每个基准测试函数运行所花的时间，
它会尝试在真正运行基准测试前先尝试用较小的N运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。
* 快的程序往往是伴随着较少的内存分配。-benchmem命令行标志参数将在报告中包含内存的分配数据统计
* go test -bench=. -benchmem
* 比较型的基准测试就是普通程序代码。它们通常是单参数的函数，由几个不同数量级的基准测试函数调用，就像这样：
```
func benchmark(B *testing.B, size int) { /** */}
func Benchmark10(B *testing.B) { benchmark(B, 10)}
func Benchmark100(B *testing.B) { benchmark(B, 100)}
func Benchmark1000(B *testing.B) { benchmark(B, 1000)}
```
* 通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。

## 11.5 剖析
* 基准测试（Benchmark）对于衡量特定操作的性能是有帮助的，但是当我们试图让程序跑的更快的时候，我们通常并不知道从哪里开始优化。
* 当我们想仔细观察我们程序的运行速度的时候，最好的方法是性能剖析。剖析技术是基于程序执行期间一些自动抽样，然后在收尾时进行推断；最后产生的统计结果就称为剖析数据
* CPU剖析数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。  
* 堆剖析则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据。
* 阻塞剖析则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。
* 当同时使用多个标志参数时需要当心，因为一项分析操作可能会影响其他项的分析结果。
```
go test -cpuprofile=cpu.out
go test -blockprofile=block.out
go test -memprofile=mem.out
```
* 剖析对于长期运行的程序尤其有用，因此可以通过调用Go的runtime API来启用运行时剖析。
* 一旦我们已经收集到了用于分析的采样数据，我们就可以使用pprof来分析这些数据。这是Go工具箱自带的一个工具，但并不是一个日常工具，它对应go tool pprof命令。
该命令有许多特性和选项，但是最基本的是两个参数：生成这个概要文件的可执行程序和对应的剖析数据。
* 虽然go test通常在测试完成后就丢弃临时用的测试程序，但是在启用分析的时候会将测试程序保存为foo.test文件，其中foo部分对应待测包的名字。
* 通常最好是对业务关键代码的部分设计专门的基准测试。因为简单的基准测试几乎没法代表业务场景，因此我们用-run=NONE参数禁止那些简单测试。
* go test -bench=ClientServerParallelTLS64 -cpuprofile=cpu.log net/http
* go tool pprof -text -nodecount=10 ./http.test cpu.log
参数-text用于指定输出格式，在这里每行是一个函数，根据使用CPU的时间长短来排序。
其中-nodecount=10参数限制了只输出前10行的结果。对于严重的性能问题，这个文本格式基本可以帮助查明原因了。
* 对性能占很大比重。相比之下，如果一个概要文件中主要是runtime包的内存分配的函数，那么减少内存消耗可能是一个值得尝试的优化策略
* 对于一些更微妙的问题，你可能需要使用pprof的图形显示功能。这个需要安装GraphViz工具，可以从 http://www.graphviz.org 下载。参数-web用于生成函数的有向图，标注有CPU的使用和最热点的函数等信息。￿

## 11.6 示例函数
* go test 示例函数 以 Example为函数名开头,示例函数没有函数参数和返回值
* 示例函数有三个用处。最主要的一个是作为文档：一个包的例子可以更简洁直观的方式来演示函数的用法，比文字描述更直接易懂，特别是作为一个提醒或快速参考时。
一个示例函数也可以方便展示属于同一个接口的几种类型或函数之间的关系，所有的文档都必须关联到一个地方，就像一个类型或函数声明都统一到包一样。
同时，示例函数和注释并不一样，示例函数是真实的Go代码，需要接受编译器的编译时检查，这样可以保证源代码更新时，示例代码不会脱节。
```
func ExampleIsPalindrome() {
    fmt.Println(IsPalindrome("A man, a plan, a canal: Panama"))
    fmt.Println(IsPalindrome("palindrome"))
    // Output:
    // true
    // false
}
```
* 根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，
因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。
* 示例函数的第二个用处是，在go test执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的// Output:格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配。
* 示例函数的第三个目的提供一个真实的演练场。 http://golang.org 就是由godoc提供的文档服务，
它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数，就像图11.4所示的那样。这通常是学习函数使用或Go语言特性最快捷的方式




