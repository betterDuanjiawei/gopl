# 5. 函数
* 函数包含连续执行的语句,函数对它的使用者隐藏了实现细节
## 5.1 函数声明
* 每一个函数声明都包含一个名字 一个形参列表 一个可选的返回值列表以及函数体
```
func name(parameter-list) (resutl-list) {
    body
}
```
* 形参列表指定了一组变量的参数名和参数类型,这些局部变量由调用者提供的实参传递而来.返回列表指定了函数返回值的类型.当函数返回一个未命名的返回值或没有返回值的时候,返回列表的圆括号可以省略.如果一个函数即省略返回列表也没有任何返回值,那么设计这个函数的目的是调用函数之后所带来的附加效果
* 返回值也可以像形参一样命名.这个时候,每一个命名的返回值会声明为一个局部变量,并根据变量类型初始化为相应的零值
* 当函数存在返回列表时,必须显式的的以 return语句结束,除非函数明确不会走完整个执行流程,比如在函数中抛出宕机异常或者函数体内存在一个没有 break退出条件的无限 for循环
* 如果几个形参或者返回值类型相同,那么类型只需要写一次.
```
// 空白标识符用来强调这个形参在函数中未使用
func add(x int, y int) int {return x+y}
func sub(x, y int) (z int) {z = x -y ; return }
func first(x int, _ int) int {return x}
func zero(int, int) int {return 0} 
fmt.Printf("%[1]T\n", add) 都是 func(int, int) int
```
* 函数的类型称为函数签名.当两个函数拥有相同的形参列表和返回值列表时,认为这个两个函数的类型或签名是相同的.而形参和返回值的名字不会影响到函数类型,采用简写同样也不会影响到函数的类型.
* 每一次调用函数都需要提供实参来对应函数的每一个形参,包括参数的调用顺序也必须一致.go 语言没有默认参数值的概念,(a = true )也不能指定实参名.
* 形参变量都是函数的局部变量,初始值由调用者提供的实参传递,函数形参以及命名返回值同属于函数最外层作用域的局部变量
* 函数的声明没有函数体, 那说明这个函数使用了除了 go 以外的语言实现. 这样的声明定义了该函数的签名
```
package math
func Sin(x float64) float64 // 使用汇编语言
```
## 5.2 递归
* 函数可以递归调用,这意味着函数可以直接或间接的调用自己.
* golang.org/x/net/html html.Parse() 读入一段字节序列,解析它们,然后返回 HTML 文档树的根节点 html.Node.
* go 语言实现了可变长度的栈,栈的大小会随着使用而增长,可达到1GB左右的上限,这使得我们可以安心的使用递归,而不用担心溢出的问题

## 5.3 多返回值
* 一个函数不止能返回一个结果.返回一个期望得到的结果和一个错误值或者一个表示函数调用是否正确的布尔值.
* fmt.Errorf() 格式化处理过的附加上下文信息. `return nil, fmt.Errorf("xxx %v", err)`
* 显式的将多个返回值赋值给变量, 如果要忽略某个一个返回值,可以将它赋值给一个空标识符
```
links, err := findLinks(url)
links, _  := findLinks(url) //
```
* 返回一个多值结果可以是调用另一个多值返回的函数. `return xxx()`
* 传递到拥有多个形参的函数中,方便调试 fmt.Println(xxx())
* 一个函数如果有命名的返回值.可以省略return 语句的操作数,称为裸返回. (word string)  return 
* 裸返回是将每个命名返回结果按照顺序返回的快捷方法.
* 裸返回可以消除重复代码,但是不能使代码易理解.保守使用裸返回

## 5.4 错误
* 如果当函数调用发生错误时返回一个附加的结果作为错误值,习惯上将错误值作为最后一个结果返回,如果错误只有一种情况,结果通常设置未bool 值,
* i/o操作,错误的原因可能多种多样.调用者需要详细的信息,这种情况下错误类型是:error
* error是内置的接口类型.一个错误可能是空值和非空值,空值意味着成功,而非空值意味着失败.而且非空的错误类型有一个错误消息字符串.
* go 使用普通的值而非异常来报告错误

### 5.4.1 错误处理策略
* 1.将错误传递下去
* 2.构建一个新的错误,添加其他有用的错误信息

* 对于不固定或不可预测的错误,在短暂间隔之后,对操作进行重试是合理的.超出一定的重试次数和限定的时间后再报错退出


## 5.6 匿名函数
* 命名函数只能在包级别的作用域进行声明,但我们能够使用函数字面量在任何表达式内指定函数变量.
* 函数字面量就像函数声明,但是在 func 关键字之后没有函数名称,而且没有(),它是一个表达式,它的值称为匿名函数
* 函数字面量在我们使用的时候才定义 `strings.Map(func (r rune) rune {return r + 1 }, "HAL-9000)`
* 匿名函数可以获取到整个词法环境,因此里层的函数可以使用外层函数的变量.
* 里层的匿名函数可以获取和更新外层squares函数的局部变量,这些隐藏变量的引用就是函数归类为引用类型而且函数变量无法进行比较的原因
* 函数变量 闭包
* 变量的生命周期不是由其作用域决定的