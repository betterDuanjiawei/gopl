# go 入门
## hello world
* go 是编译型语言,go 的工具链将程序的源文件转变成机器相关的原生二进制指令
* go run x,x... 它将一个或者多个以.go后缀的源文件进行编译 链接,然后运行生成的可执行文件
* go 原生的支持 unicode编码,它可以处理所有国家的语言
* go build x 编译生成成一个可重复执行的二进制程序

* go 的代码是使用 包(package) 来组织的,类似其他语言的库和模块.
* 一个包由一个或者多个.go源文件组成,放在一个文件夹中,该文件夹的名字描述了包的作用.每一个源文件都使用package声明,指明了这个文件属于哪个包,然后跟着import导入其他包的包列表,然后是存储在文件中的程序声明
* main main包比较特殊,它用来定义一个可独立执行的程序,而不是库,在 main 包中,main 函数也是特殊的,不管在什么程序中,main()做什么事情,它总是程序开始执行的地方
* import 必须跟在package声明后面, import 导入 的 包是没有顺序关系的.gofmt工具会按照字母顺序表进行排序  import 导入之后是程序的函数 变量 常量 类型声明等
* go不需要在语句或者声明后面加;分号结尾,除非有多个语句或者声明出现在同一行.
* func() { 中 {必须和 func关键字在同一行,不能独自成行
* gofmt 工具将代码以标准格式重写 goimports 可以按需管理导入声明的插入和移除,通过(go get golang.org/x/tools/cmd/goimports)获取

## 命令行参数
### os包
* os包提供一些函数和变量,以与平台无关的方式和操作系统打交道.命令行参数以 os.Args 变量供程序访问.
* os.Args 是一个字符串 slice;
* slice 动态容量的顺序数组s,通过 s[i]来访问单个元素,通过 s[m:n]来访问一段连续子区间,长度用 len(s)表示,所有索引采用半开区间,即>=m   < n,包含第一个元素,不包含最后一个元素
* os.Args[0] 他是命令本身, 另外的元素是程序执行时的参数. os.Args[1:len(os.Args)]
```
os.Args[0]
// go run echo1.go 的结果/var/folders/gd/6znpcr_57pb7k9s59h0395_w0000gp/T/go-build366445065/b001/exe/echo1
// ./echo1  的结果 ./echo1
```
* var 关键字对变量进行声明,如果声明后没有进行明确的初始化,它将隐式的初始化为这个类型的空值. 对数字的初始化空值是0,字符串是""
* go中 对于字符串 + 是连接作用, 对于数字是求和
* += 是赋值操作
* := 短变量声明
* i++  -> i += 1 -> i = i + 1 相等的 这些是语句,不是声明, 所以 y = i++ 不合法, 只支持后缀 ++i不合法
* for 是 go 中的唯一循环语句. 

```
for 初始化(在循环执行前开始执行); 条件(布尔表达式,在循环的每一次迭代开始前推演,结果是真,则循环继续,变成假,循环结束); post {
    // 一个或多个语句
}
三部分都可以省略
// 只有条件,没有分号; 相当于 while循环
for 条件 {

}
// 无限循环
for {
    // break 或 return终止
}
```

* _ 空标识符  go不允许存在无用的临时变量,否则编译会报错. 空标识符可以用在任何语法需要但是程序逻辑不需要的地方
* 变量声明方式:

```
s := ""             // 使用多 短变量声明简洁,通常用在函数内部使用,不适合包级别的变量, 隐式声明的初始化来声明变量的不重要
var s string        // 使用多 默认初始化为""字符串, 显式初始化来说明初始化变量的重要性,
var s = ""          // 很少用,除非声明多个变量
var s string = ""   // 显式的变量类型,在类型一致的情况下是冗余的,在类型不一致的情况下是必须的.
```

* strings.Join(slice, 分隔符) 只能操作元素类型为 string的数组 将一个数组 slice的每一个元素用分隔符连接成一个字符串,相比自己写循环连接更加高效  相反的 strings.Split(s, 分隔符) 分割成 slice
* fmt.Println(slice) 可以直接输出,形式为:[php java py js]
* if 语句也不放在()里,但是程序体用到了大括号
* map 是一个使用 make创建的数据结构的引用.当一个 map 被传递给一个函数时,函数接收到这个引用的副本,所以被调用函数中对于 map 数据结构中的改变对函数的调用者是用的 map引用也是可见的.

* io/ioutil 包中的 ReadFile() 读取一个文件的全部内容,返回一个可以转化为字符串string的字节 slice[]byte
* 在导入那些由多段路径如 io/ioutil组成的包之后,使用路径最后的一段来引用一个包 如:ioutil.ReadFile()
* const 关键字 常量,用来给常量声明,常量时在编译期间固定的量, 常量必须时数字 字符串 布尔值
* 表达式[]color.Color{...} 和 gif.GIF{...}是复合字面量,即用一系列元素的值初始化 go的复合类型的紧凑表达式. 左边两个分别时:slice 结构体
* gif.GIF 是的一个结构体类型, 结构体由一组称为字段的值组成,字段通常有不同类型的数据,它们一起组成单个对象,作为一个单位被对待, 结构体的每个字段可以通过. 点记法来访问, 如果没有赋值,那么它的字段对应的类型是零值