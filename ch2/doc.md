# 2.程序结构
* go语言的大程序都是从小的基本组件构建来的
    * 变量存储值;
    * 简单的表达式通过加或减等操作合成大的;
    * 基本类型通过数组或结构体进行聚合;
    * if for等流程控制语句来决定执行的顺序;
    * 语句被组织成函数用于复用和隔离
    * 函数被组织成源文件和包
## 名称
* 命名规则:以字母或_开头,后面可以跟任意数量的字符 下划线 数字,区分大小写 heapSort Heapsort 是不同的名称
* go 有25个关键字,只能用在语法允许的地方,不能用作名称
```cassandraql
break       default         func        interface       select
case        defer           go          map             struct
chan        else            goto        package         switch
const       fallthrough     if          range           type
contiue     for             import      return          var
```
* 30多个内置的预声明的常量 类型 函数, 可以声明,但是要注意冲突的风险
```cassandraql
常量: true false iota nil
类型: int int8 int16 int32 int64
    uint uint8 uint16 uint32 uint64 uintptr
    float32 float64 complex128 complex64
    bool byte rune string error
函数: make append delete close len cap copy new
    complex real imag
    panic recover
    
```
* 如果一个实体在函数内部声明,那么它只在函数局部有效,如果声明在函数外,它将对包里的所有源文件可见,实体的第一个字母的大小写决定其可见性是否跨包,
* 以大写字母开头,它是可以导出的,意味着它对包内和包外都可见,可以被包外的其他程序所引用
* 包名本身总是由小写字母组成
* 名称 go 偏向短名称, 作用域较小的变量 i,名称的作用域越大,就是用越长而且有意义的名称
* 驼峰法,用大写字母, 不用下划线法

## 声明
* 声明给程序实体命名,并设定其一部分或全部属性,主要的4种声明: 变量 var 常量 const 类型 type 函数 func
* .go 结尾文件, package 开头 import 导入,包级别的类型 变量 常量 函数,不区分顺序,
* 函数的声明包含一个名字 一个参数列表(由函数的调用者提供的变量) 一个返回值列表 函数体(包含具体逻辑),如果函数不返回任何内容,则返回值列表可以省略,函数的执行从第一个语句开始,直到遇到一个返回语句,或执行到无返回结果的函数的结尾.
* 常量的声明没有:,const pi = 3.1415

## 变量
* var 声明创建一个具体类型的变量,然后给它附加一个名字,设置它的初始值,通用形式:
`var name type = expression(表达式)`
类型和表达式可以省略一个,但是不可都省略,如果只省略类型,它类型由初始化表达式决定,如果表达式省略,其初始值对应于类型的零值,
    * 数字:0
    * 字符串:""
    * 接口和引用类型(slice map chan point func):nil
    * 数组和结构体这样的复合类型,零值是其所有元素或成员的零值
* 零值机制保证了所有的变量都是良好定义的,go不存在未初始化的变量,
* 忽略类型声明允许声明不同类型变量 `var a, b, c, d = 1, "djw", true, 2.3`
* 初始值的设定可以是字面量或者任何表达式
* 包级别的初始化在 main开始之前进行,局部变量初始化和声明在函数执行期间进行
* 变量可以通过调用返回多个值的函数进行初始化 `var f, err = os.Open(file)`

### 短变量声明
* 在函数中,短变量声明可以用来声明和初始化局部变量,`name := expression` name 的类型由 expression的类型决定,
* 短小灵活,局部变量的声明和初始化主要是短变量声明,
* 多个初始化表达式: 多个变量同时声明初始化 `i, j := 1, 2`
* := 声明 = 赋值
* 交换值 `i, j = j, i`
* 短变量声明不需要声明所有在左边的变量,如果一些变量已经在语法块中声明,那么对于那些变量,短声明的方式等同于赋值
* 短变量声明最少声明一个变量,否则编译无法通过

### 指针
* 变量是存储值的地方
* 指针的值是变量的地址,不是所有的值都有地址,但是所有变量都有,使用指针,可以在无须知道变量名的情况下,间接更新和读取变量的值
* var x int, &x(x 的地址)获取了一个指向整型变量的指针,它的类型是整形指针(*int), *p 变量,可以出现在赋值操作符的左边,更新变量
```cassandraql
x := 1
p := &x
*p = 2 // x = 2
```
* 每一个聚合类型变量的组成(数组的元素或者结构体的成员)都是变量,都有一个地址
* 指针类型的零值是 nil  p != nil, true 说明指向一个变量,
* 指针是可比较的,只有两个指针指向同一个变量或者都为 nil 时候才相等


### new 函数
* new(T) 创建一个未命名的 T类型的变量,初始化为T类型的零值,并返回其地址(地址类型为*T)
```cassandraql
p := new(int)
fmt.Print(*p) //0
*p = 2
fmt.Print(*p) // 2
```
* new()创建不需要声明一个虚拟的名字,new()是语法上的便利,不是一个基础概念
```cassandraql
func m() *int {
    return new(int)
}

func n() *int {
    var tmp int
    return &tmp
}
```
* 每次调用 new(T)返回一个具有唯一地址的不同变量,具有相同地址值的例外:两个变量的类型不携带任何信息而且是零值,struct{} 和 [0]int,他们具有相同的地址
```
p := new(int)
q := new(int)
fmt.Println(p == q)
```
* new()是一个预声明函数,不是一个关键字,所以它可以重定义为另外的其他类型.

### 变量的生命周期
* 生命周期指变量在程序执行过程期间存在的时间段
* 变量一直生存到它变得不可访问,这时它占用的存储空间被回收
* 函数的参数和返回值也是局部变量,他们在函数被调用的时候创建
* 变量的生命周期是通过它是否可达来确定
* 变量逃逸
```
var global *int
func f() {
    var x int
    x  = 1
    global = &x 
}
x 变量可以通过 global 访问, *global,x从f中逃逸
```

### 赋值
* 赋值:更新变量所指的值,形式 赋值符号和左边的变量和右边的表达式组成.
```
x = true // 有名称的变量
*p = 1 // 间接变量
person.age = 18 // 结构体成员
count[x] = count[x] * 8 // 数组或者 slice 或 map的元素
count[x] *= 8
v := 1
v++ // v = v + 1
v-- // v = v - 1
```

### 多重赋值
* 多重赋值允许多个变量一次性被赋值,在更新实际变量之前,右边的所有表达式被推演
* 当变量同时出现在赋值符号两侧时候,特别有用 比如交换 x y 的值
```
x, y = y, x
a[i], a[j] = a[j], a[i]
// 求两个数的最大公约数
func gcd(x, y int) int {
    for y != 0 {
        x,y = y, x%y
    }
    return x
}
// 计算斐波那契的第 n 个数
func fib(n int) int {
    x, y := 0, 1
    for i := 0; i < n; i++ {
        x, y = y, x+y
    }
    return x
}
```
* err error类型 ok bool 类型
``` 
v, ok = m[key] // map 查询
v, ok = x.(T) // 类型断言
v, ok = <-ch // 通道接收
```
* 像变量声明一样,可以将不需要的值赋值给空标识符
```
_, err = io.Copy(dst, src) // 丢弃字节个数
_, ok = x.(T) // 检查类型但丢弃结果
```

### 可赋值性
* 赋值语句是显式形式的赋值,但是程序有很多地方是隐式的赋值:函数调用隐式地将参数的值赋值给对应参数的变量,一个 return语句隐式的将结果赋值给返回值
* 复合类型的字面量表达式,slice `medals := []string{"gold", "silver", "bronze"}`
* map和通道一样也遵从相识的隐式赋值
* 不管是隐式赋值还是显示赋值,如果左边的变量和右边的值类型是相同的,它就是合法的.

## 类型声明
* type 声明定义一个新的命名类型,它和已有的某个类型使用相同的底层类型,命名类型提供了一种方式来区分底层类型的不同或不兼容使用,这样它们就不会在无意中混用了
* type name underlying-type
* 类型的声明通常出现在包级别.整个包可见,大写可导出
* 显示类型转换x(T),不是函数调用, 浮点型转整数会有精度的丢失,字符串转泡[]byte 字节 slice会分配一份字符串副本

## 包和文件
* 导出的标识符以大写字母开头
* 导入 import
* 如果导入一个没有被使用的包,就触发一个错误,编译器报错,没有导入直接使用也会报错

### 包的初始化
* 包的初始化从初始化包级别的变量开始
* 在程序 main 函数开始执行前,所有的包都已经初始化完毕

## 作用域
* 不要把作用域和生命周期混淆,声明的作用域是声明在程序文本出现的区域,是一个编译时属性,生命周期是变量在程序执行期间能被其他的部分所引用的起止时间,它是一个运行时属性.
* 语法块{}是由{}围起来的语句序列,在语法块内部声明的变量对块外部不可见,块把声明包起来,并决定了它的可见性.
* 词法块 包含了全部源代码的词法块,叫做全局块
* 编译器遇到一个变量时,从最内层的封闭词法块到全局块寻找其声明,如果同时存在,内存会覆盖外层
* 变量不使用会报错
```
if f, err := os.Open(filename); err != nil {
    return err
} else {
    f.Stat() // 这里 f是可见的
    f.Close() 
}

var cwd string
func main() {
    var err error
    cwd, err = os.Getwd() // 如果用:=的话,就会有一个局部的新 cwd 变量声明,会覆盖掉包变量 cwd 的
    if err != nil {
        //
    }

}
```




