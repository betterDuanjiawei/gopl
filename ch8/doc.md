# goroutine 和 通道
## 8.4 通道
* goroutine 是go并发的执行体, channel 是它们之间的连接, 通道是可以让一个 goroutine发送特定值到 另一个 goroutine的通信机制. 每个通道都是一个具体类型的导管,叫做通道的元素类型.
* 创建: 
内置make()创建通道
`ch := make(chan int) // ch的元素类型是 chan int, int类型元素的通道`
* 引用类型: 和 map一样,make创建的是一个引用类型,和其他引用类型一样,通道的零值是 nil
* 可比较性 同种类型的通道可以用==来比较,当两者都是同一类型的引用时候,比较结果为 true;通道也可以和 nil进行比较
* 操作: send 发送 receive 接收 统称通信

```
<-操作符
ch <- x // 发送
y = <-ch // 赋值语句中的接收表达式 接收时候<-ch,可以连接
<-ch //接收语句,丢弃结果
```

close 关闭操作 内置的 close(ch)函数来关闭通道
* 无缓冲通道和有缓冲通道: 通过 make()创建的第二个参数来指定缓冲通道的容量

```
make 函数初始化变量时候,有:,除非是之前已经声明过变量了
ch1 := make(chan int) // 无缓冲通道
ch2 := make(chan int, 0) // 无缓冲通道
ch3 := make(chan int, 3) // 容量为3的缓冲通道
```

* 无缓冲通道(同步通道): 发送和接收同步化,发送阻塞,直到另一个 goroutine 在对应的通道上执行接收操作,这时候传送完成,两个 goroutine可以继续执行.
* 通道可以用来传递数据,消息的值,这种消息称为事件,如果没有任何额外信息,单纯就是进行同步,可以用 struct{} bool int 来做通道的元素类型
### 8.4.2 管道
* 通道可以用来连接 goroutine,这样一个的输出是另一个的输入,这个叫管道(pipeline)
* 在通道关闭后,任何后续的发送操作都会导致应用崩溃,
* range 语法可以在通道上进行迭代.这个语法更方便接收在通道上发送的值,接受完最后一个值后,关闭循环
* 只有在通知接收方 goroutine所有的数据是否发送完成时候才需要关闭通道, 不是必须的.
* close() 通道的关闭 和 x.Close() 资源的关闭 不要混淆了
* 试图关闭一个已经关闭的通道会导致宕机
`naturals := make(chan int)
close(naturals)
close(naturals)
`
### 8.4.2 单向通道类型
* 函数的形参,总是有意的限制不能发送或者接受
* out chan<-  int 发送通道  in <-chan int 接收通道
* 双向可以转单向(隐式),但是逆向操作不 ok
